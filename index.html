<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monkey Tag Online</title>
<style>
  * { margin:0;padding:0;box-sizing:border-box; }
  body { background:#000;overflow:hidden;font-family:'Courier New',monospace;cursor:default; }
  canvas { display:block; }
  body.ingame { user-select:none; }

  #menu {
    position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
    background:rgba(8,16,8,0.98);border:2px solid #00ff44;border-radius:6px;
    padding:40px 50px;text-align:center;z-index:100;
    box-shadow:0 0 60px rgba(0,255,68,0.25);min-width:340px;
  }
  #menu h1 { font-size:2.6rem;font-weight:900;letter-spacing:.12em;color:#00ff44;text-shadow:0 0 30px #00ff44;text-transform:uppercase;margin-bottom:4px; }
  #menu .sub { color:#335533;font-size:.75rem;letter-spacing:.3em;text-transform:uppercase;margin-bottom:30px; }
  .ig { margin-bottom:14px;text-align:left; }
  .ig label { color:#557755;font-size:.68rem;letter-spacing:.2em;text-transform:uppercase;display:block;margin-bottom:5px; }
  .ig input { width:100%;padding:11px 14px;background:#0a150a;border:1px solid #1a331a;color:#00ff44;font-family:'Courier New',monospace;font-size:1rem;border-radius:3px;outline:none;transition:border-color .2s; }
  .ig input:focus { border-color:#00ff44; }
  .btn { width:100%;padding:13px;margin-top:8px;background:transparent;border:2px solid #00ff44;color:#00ff44;font-family:'Courier New',monospace;font-size:.9rem;font-weight:700;letter-spacing:.2em;text-transform:uppercase;cursor:pointer;border-radius:3px;transition:all .15s; }
  .btn:hover { background:#00ff44;color:#000;box-shadow:0 0 20px rgba(0,255,68,.4); }
  .btn.sec { border-color:#1a331a;color:#335533; }
  .btn.sec:hover { border-color:#00ff44;color:#00ff44;background:transparent;box-shadow:none; }

  #hud { position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none; }
  #crosshair { position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:14px;height:14px; }
  #crosshair::before,#crosshair::after { content:'';position:absolute;background:rgba(255,255,255,.7); }
  #crosshair::before { width:2px;height:14px;left:6px;top:0; }
  #crosshair::after  { width:14px;height:2px;left:0;top:6px; }
  #pcount { position:fixed;top:18px;right:18px;color:#00ff44;font-size:.78rem;letter-spacing:.1em;text-shadow:0 0 8px #00ff44; }
  #lcode  { position:fixed;top:18px;left:18px;color:#335533;font-size:.7rem;letter-spacing:.08em; }
  #hint   { position:fixed;bottom:18px;left:50%;transform:translateX(-50%);color:#2a472a;font-size:.68rem;letter-spacing:.12em;text-transform:uppercase;white-space:nowrap; }
  #status { position:fixed;bottom:50px;left:50%;transform:translateX(-50%);color:#00ff44;font-size:.82rem;letter-spacing:.1em;text-shadow:0 0 10px #00ff44;opacity:0;transition:opacity .4s;text-transform:uppercase;background:rgba(0,0,0,.6);padding:6px 18px;border-radius:3px; }
  #rmb-hint { position:fixed;top:55%;left:50%;transform:translate(-50%,-50%);color:rgba(255,255,255,.4);font-size:.8rem;letter-spacing:.1em;text-transform:uppercase;pointer-events:none;transition:opacity .8s; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="menu">
  <h1>ğŸ¦ Monkey Tag</h1>
  <div class="sub">online Â· multiplayer</div>
  <div class="ig">
    <label>Your Name</label>
    <input type="text" id="nameInput" placeholder="Enter name..." maxlength="16" value="Monkey">
  </div>
  <button class="btn" id="joinPublicBtn">â–¶ Join Public Lobby</button>
  <button class="btn sec" id="hostBtn">âŠ• Host Private Lobby</button>
  <div id="privateBox" style="display:none;margin-top:14px;">
    <div class="ig"><label>Lobby Code</label><input type="text" id="codeInput" placeholder="Enter code..." maxlength="8"></div>
    <button class="btn" id="joinPrivBtn">â†’ Join Private</button>
  </div>
</div>

<div id="hud">
  <div id="crosshair"></div>
  <div id="pcount">Players: 1</div>
  <div id="lcode"></div>
  <div id="hint">WASD Â· Move &nbsp;|&nbsp; SPACE Â· Jump / Bunny Hop &nbsp;|&nbsp; RIGHT CLICK Â· Look</div>
  <div id="status"></div>
  <div id="rmb-hint">Hold Right Click to look around</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const WS_SERVER = 'wss://proactive-beauty-production.up.railway.app';

// â”€â”€ RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x7ec8e3);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x7ec8e3, 0.013);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 300);
const CAM_DIST=5.5, CAM_HEIGHT=2.8;

// â”€â”€ LIGHTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sun = new THREE.DirectionalLight(0xfff8e0,1.4);
sun.position.set(40,80,30); sun.castShadow=true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.far=200;
sun.shadow.camera.left=sun.shadow.camera.bottom=-60;
sun.shadow.camera.right=sun.shadow.camera.top=60;
scene.add(sun);
scene.add(new THREE.AmbientLight(0x88bbdd,0.7));
scene.add(new THREE.HemisphereLight(0x87ceeb,0x2d5a1b,0.5));

// â”€â”€ BASEPLATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PLATE_SIZE=100, PLATE_DIVS=20, tileSize=PLATE_SIZE/PLATE_DIVS;
const baseSlab = new THREE.Mesh(
  new THREE.BoxGeometry(PLATE_SIZE,1.5,PLATE_SIZE),
  new THREE.MeshLambertMaterial({color:0x3a6020})
);
baseSlab.position.y=-0.75; baseSlab.receiveShadow=true; scene.add(baseSlab);

const tileGeo=new THREE.BoxGeometry(tileSize-.08,.15,tileSize-.08);
const tM1=new THREE.MeshLambertMaterial({color:0x55a035});
const tM2=new THREE.MeshLambertMaterial({color:0x3d7825});
for(let i=0;i<PLATE_DIVS;i++) for(let j=0;j<PLATE_DIVS;j++){
  const t=new THREE.Mesh(tileGeo,(i+j)%2===0?tM1:tM2);
  t.position.set(-PLATE_SIZE/2+tileSize*i+tileSize/2,.08,-PLATE_SIZE/2+tileSize*j+tileSize/2);
  t.receiveShadow=true; scene.add(t);
}
const edgeMat=new THREE.MeshLambertMaterial({color:0x224410});
[[0,PLATE_SIZE/2+.5,PLATE_SIZE+2,1],[0,-PLATE_SIZE/2-.5,PLATE_SIZE+2,1],
 [PLATE_SIZE/2+.5,0,1,PLATE_SIZE+2],[-PLATE_SIZE/2-.5,0,1,PLATE_SIZE+2]].forEach(([x,z,w,d])=>{
  const e=new THREE.Mesh(new THREE.BoxGeometry(w,.9,d),edgeMat);
  e.position.set(x,.2,z); scene.add(e);
});

// â”€â”€ PLATFORMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const platformDefs=[
  {x:-10,y:3, z:-10,w:7,d:7,c:0xcc3322},{x:10, y:3, z:-10,w:7,d:7,c:0x2233cc},
  {x:0,  y:5, z:12, w:9,d:5,c:0xcc9911},{x:-18,y:4, z:5,  w:6,d:6,c:0x22aa44},
  {x:18, y:4, z:5,  w:6,d:6,c:0xaa22aa},{x:0,  y:9, z:-18,w:8,d:8,c:0xdd6600},
  {x:-14,y:7, z:-18,w:5,d:5,c:0x0099cc},{x:14, y:7, z:-18,w:5,d:5,c:0xcc0066},
  {x:0,  y:13,z:0,  w:6,d:6,c:0xffcc00},{x:-8, y:6, z:18, w:4,d:4,c:0xff44aa},
  {x:8,  y:6, z:18, w:4,d:4,c:0x44ffaa},
];
const platforms=platformDefs.map(p=>{
  const m=new THREE.Mesh(new THREE.BoxGeometry(p.w,1.2,p.d),new THREE.MeshLambertMaterial({color:p.c}));
  m.position.set(p.x,p.y,p.z); m.castShadow=true; m.receiveShadow=true; scene.add(m);
  return{...p,h:1.2};
});

// â”€â”€ TREES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[[-25,5],[25,5],[-25,-22],[25,-22],[0,-30],[0,28],[-35,0],[35,0]].forEach(([x,z])=>{
  const g=new THREE.Group();
  const tk=new THREE.Mesh(new THREE.CylinderGeometry(.35,.5,6,9),new THREE.MeshLambertMaterial({color:0x7a4a1e}));
  tk.position.y=3; tk.castShadow=true;
  const lv=new THREE.Mesh(new THREE.SphereGeometry(3.5,10,8),new THREE.MeshLambertMaterial({color:0x1e8b3a}));
  lv.position.y=8; lv.castShadow=true;
  g.add(tk,lv); g.position.set(x,0,z); scene.add(g);
});

// â”€â”€ JUMP VFX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ring that expands on the ground when jumping
const vfxRings = [];
function spawnJumpRing(x, y, z) {
  const geo = new THREE.RingGeometry(0.1, 0.35, 24);
  const mat = new THREE.MeshBasicMaterial({ color:0x88ffcc, transparent:true, opacity:0.85, side:THREE.DoubleSide });
  const ring = new THREE.Mesh(geo, mat);
  ring.rotation.x = -Math.PI/2;
  ring.position.set(x, y+0.05, z);
  scene.add(ring);
  vfxRings.push({ mesh:ring, age:0, maxAge:0.45 });

  // Also spawn dust particles
  for(let i=0;i<8;i++){
    const angle = (i/8)*Math.PI*2;
    const pGeo = new THREE.SphereGeometry(0.07,4,4);
    const pMat = new THREE.MeshBasicMaterial({ color:0xccffaa, transparent:true, opacity:0.9 });
    const p = new THREE.Mesh(pGeo,pMat);
    p.position.set(x,y+0.1,z);
    const speed = 2.5+Math.random()*1.5;
    scene.add(p);
    vfxRings.push({
      mesh:p, age:0, maxAge:0.35,
      vx: Math.cos(angle)*speed, vy: 2+Math.random()*2, vz: Math.sin(angle)*speed,
      isDust:true
    });
  }
}

function updateVFX(dt){
  for(let i=vfxRings.length-1;i>=0;i--){
    const v=vfxRings[i];
    v.age+=dt;
    const t=v.age/v.maxAge; // 0â†’1
    if(v.isDust){
      v.mesh.position.x+=v.vx*dt;
      v.mesh.position.y+=v.vy*dt; v.vy-=12*dt;
      v.mesh.position.z+=v.vz*dt;
      v.mesh.material.opacity=0.9*(1-t);
      v.mesh.scale.setScalar(1-t*0.5);
    } else {
      v.mesh.scale.setScalar(1+t*4);
      v.mesh.material.opacity=0.85*(1-t);
    }
    if(v.age>=v.maxAge){ scene.remove(v.mesh); vfxRings.splice(i,1); }
  }
}

// Land puff VFX
function spawnLandPuff(x,y,z){
  for(let i=0;i<6;i++){
    const angle=(i/6)*Math.PI*2;
    const pGeo=new THREE.SphereGeometry(0.09,4,4);
    const pMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.7});
    const p=new THREE.Mesh(pGeo,pMat);
    p.position.set(x,y+0.08,z);
    const speed=1.5+Math.random();
    scene.add(p);
    vfxRings.push({mesh:p,age:0,maxAge:0.28,vx:Math.cos(angle)*speed,vy:1,vz:Math.sin(angle)*speed,isDust:true});
  }
}

// â”€â”€ MONKEY BUILDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeNameTex(name){
  const c=document.createElement('canvas'); c.width=256;c.height=64;
  const ctx=c.getContext('2d');
  ctx.clearRect(0,0,256,64);
  ctx.fillStyle='rgba(0,0,0,0.6)';
  ctx.beginPath();if(ctx.roundRect)ctx.roundRect(2,2,252,60,10);else ctx.rect(2,2,252,60);ctx.fill();
  ctx.font='bold 26px Courier New';ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.fillStyle='#00ff88';ctx.fillText(name.substring(0,14),128,32);
  return new THREE.CanvasTexture(c);
}

function buildMonkey(color){
  const g=new THREE.Group();
  const mat=new THREE.MeshLambertMaterial({color});
  const faceMat=new THREE.MeshLambertMaterial({color:0xffb07a});
  const eyeMat=new THREE.MeshLambertMaterial({color:0x111111});
  const whiteMat=new THREE.MeshLambertMaterial({color:0xffffff});
  const darkMat=new THREE.MeshLambertMaterial({color:0x331100});
  const browMat=new THREE.MeshLambertMaterial({color:0x220800});

  const body=new THREE.Mesh(new THREE.SphereGeometry(.44,12,9),mat);
  body.scale.y=1.18;body.position.y=.82;body.castShadow=true;g.add(body);

  const headG=new THREE.Group();headG.position.y=1.54;
  const head=new THREE.Mesh(new THREE.SphereGeometry(.36,12,10),mat);
  head.castShadow=true;headG.add(head);
  const snout=new THREE.Mesh(new THREE.SphereGeometry(.2,10,8),faceMat);
  snout.scale.set(1.1,.72,.88);snout.position.set(0,-.04,.3);headG.add(snout);
  [[-.07,-.01,.46],[.07,-.01,.46]].forEach(([x,y,z])=>{
    const n=new THREE.Mesh(new THREE.SphereGeometry(.045,6,5),darkMat);n.position.set(x,y,z);headG.add(n);
  });
  [-.12,.12].forEach((dx,i)=>{
    const ew=new THREE.Mesh(new THREE.SphereGeometry(.085,8,7),whiteMat);ew.position.set(dx,.1,.3);headG.add(ew);
    const ep=new THREE.Mesh(new THREE.SphereGeometry(.058,8,7),eyeMat);ep.position.set(dx,.1,.355);headG.add(ep);
    const brow=new THREE.Mesh(new THREE.BoxGeometry(.11,.03,.04),browMat);
    brow.position.set(dx,.21,.335);brow.rotation.z=i===0?.25:-.25;headG.add(brow);
  });
  [-1,1].forEach(s=>{
    const ear=new THREE.Mesh(new THREE.SphereGeometry(.12,8,6),mat);ear.position.set(s*.36,.1,0);headG.add(ear);
    const ei=new THREE.Mesh(new THREE.SphereGeometry(.07,7,5),faceMat);ei.position.set(s*.42,.1,.04);headG.add(ei);
  });
  g.add(headG);

  function makeArm(side){
    const ag=new THREE.Group();ag.position.set(side*.48,.9,.02);ag.rotation.z=side*.32;
    const sh=new THREE.Group();
    const up=new THREE.Mesh(new THREE.CylinderGeometry(.1,.09,.55,8),mat);up.position.y=-.28;up.castShadow=true;sh.add(up);
    const el=new THREE.Group();el.position.y=-.56;
    const lo=new THREE.Mesh(new THREE.CylinderGeometry(.08,.07,.5,8),mat);lo.position.y=-.25;lo.castShadow=true;el.add(lo);
    const ha=new THREE.Mesh(new THREE.SphereGeometry(.1,8,6),faceMat);ha.position.y=-.52;el.add(ha);
    sh.add(el);ag.add(sh);ag.userData.shoulder=sh;ag.userData.elbow=el;return ag;
  }
  function makeLeg(side){
    const lg=new THREE.Group();lg.position.set(side*.21,.42,0);
    const hip=new THREE.Group();
    const up=new THREE.Mesh(new THREE.CylinderGeometry(.11,.1,.52,8),mat);up.position.y=-.26;up.castShadow=true;hip.add(up);
    const kn=new THREE.Group();kn.position.y=-.53;
    const lo=new THREE.Mesh(new THREE.CylinderGeometry(.09,.08,.46,8),mat);lo.position.y=-.23;lo.castShadow=true;kn.add(lo);
    const fo=new THREE.Mesh(new THREE.BoxGeometry(.18,.1,.3),mat);fo.position.set(0,-.5,.07);kn.add(fo);
    hip.add(kn);lg.add(hip);lg.userData.hip=hip;lg.userData.knee=kn;return lg;
  }

  const armL=makeArm(-1),armR=makeArm(1),legL=makeLeg(-1),legR=makeLeg(1);
  g.add(armL,armR,legL,legR);

  const tailG=new THREE.Group();tailG.position.set(0,.7,-.4);
  for(let i=0;i<7;i++){
    const seg=new THREE.Mesh(new THREE.SphereGeometry(.075-i*.007,6,5),mat);
    const a=(i/6)*Math.PI*.9-.4;
    seg.position.set(0,Math.sin(a)*.32*i*.38,-Math.cos(a)*.14*i);tailG.add(seg);
  }
  g.add(tailG);

  const tex=makeNameTex('Player');
  const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthTest:false}));
  sprite.scale.set(2.4,.58,1);sprite.position.y=2.4;g.add(sprite);

  g.userData={headG,armL,armR,legL,legR,tailG,sprite,walkPhase:Math.random()*Math.PI*2};
  return g;
}

function setName(monkey,name){
  const sp=monkey.userData.sprite;
  sp.material.map.dispose();sp.material.map=makeNameTex(name);sp.material.needsUpdate=true;
}

function animateMonkey(monkey,moving,inAir,dt){
  const d=monkey.userData;
  if(moving)d.walkPhase+=dt*9;
  const sw=moving?Math.sin(d.walkPhase)*.6:0;
  if(inAir){
    d.armL.userData.shoulder.rotation.x=-1.1;d.armR.userData.shoulder.rotation.x=-1.1;
    d.legL.userData.hip.rotation.x=.55;d.legR.userData.hip.rotation.x=.55;
    d.legL.userData.knee.rotation.x=-.5;d.legR.userData.knee.rotation.x=-.5;
  } else {
    d.armL.userData.shoulder.rotation.x=-sw;d.armR.userData.shoulder.rotation.x=sw;
    d.legL.userData.hip.rotation.x=sw;d.legR.userData.hip.rotation.x=-sw;
    d.legL.userData.knee.rotation.x=Math.max(0,-sw)*.45;
    d.legR.userData.knee.rotation.x=Math.max(0,sw)*.45;
  }
  if(moving&&!inAir)monkey.position.y+=Math.abs(Math.sin(d.walkPhase))*.018;
  d.tailG.rotation.y=Math.sin(Date.now()*.0018)*.45;
  d.tailG.rotation.x=Math.sin(Date.now()*.0012)*.15;
}

// â”€â”€ LOCAL PLAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const COLORS=[0xff5500,0xff2233,0x2255ff,0x22cc44,0xcc22cc,0xffcc00,0x00ccff,0xff8800,0x44ffbb,0xff44bb];
const myColor=COLORS[Math.floor(Math.random()*COLORS.length)];

const player={
  pos:new THREE.Vector3(0,1.8,0), vel:new THREE.Vector3(),
  yaw:0, pitch:.25,
  onGround:false, wasOnGround:false,
  name:'Monkey', color:myColor, id:null,
  moving:false,
  // Bunny hop state
  jumpBufferTime:0,   // coyote + jump buffer
  coyoteTime:0,       // time since left ground
  bhopWindow:0,       // window to keep speed on landing
  canMove:false       // DISABLED until in lobby
};

const localMonkey=buildMonkey(player.color);
scene.add(localMonkey);

// â”€â”€ REMOTE PLAYERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const remotes={};
function spawnRemote(id,data){
  const m=buildMonkey(data.color||0xff6600);
  setName(m,data.name||'Player');
  m.position.set(data.x||0,data.y||0,data.z||0);
  scene.add(m);
  remotes[id]={monkey:m,data,prevX:0,prevZ:0,moving:false,inAir:false};
}
function removeRemote(id){if(remotes[id]){scene.remove(remotes[id].monkey);delete remotes[id];}}
function moveRemote(id,data){
  if(!remotes[id]){spawnRemote(id,data);return;}
  const r=remotes[id];
  const dx=data.x-r.prevX,dz=data.z-r.prevZ;
  r.moving=(dx*dx+dz*dz)>.0002;r.inAir=(data.y||0)>.35;
  r.prevX=data.x;r.prevZ=data.z;
  r.monkey.position.set(data.x,data.y,data.z);
  r.monkey.rotation.y=(data.yaw||0)+Math.PI;
  if(data.name&&data.name!==r.data.name){setName(r.monkey,data.name);r.data.name=data.name;}
}

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys={};
window.addEventListener('keydown',e=>{
  // block space from scrolling page
  if(e.code==='Space')e.preventDefault();
  keys[e.code]=true;
});
window.addEventListener('keyup',e=>keys[e.code]=false);

let rightMouseDown=false,mdx=0,mdy=0,rmbHintShown=false;

canvas.addEventListener('contextmenu',e=>e.preventDefault());
document.addEventListener('contextmenu',e=>{if(document.getElementById('hud').style.display!=='none')e.preventDefault();});

canvas.addEventListener('mousedown',e=>{
  if(e.button===2){
    rightMouseDown=true;
    if(!rmbHintShown){document.getElementById('rmb-hint').style.opacity='0';rmbHintShown=true;}
  }
});
window.addEventListener('mouseup',e=>{if(e.button===2)rightMouseDown=false;});
window.addEventListener('mousemove',e=>{
  if(rightMouseDown&&document.getElementById('hud').style.display!=='none'){
    mdx+=e.movementX||0; mdy+=e.movementY||0;
  }
});

// Pointer lock as alternative
canvas.addEventListener('click',e=>{
  if(e.button===0&&document.getElementById('hud').style.display!=='none')canvas.requestPointerLock();
});
let locked=false;
document.addEventListener('pointerlockchange',()=>locked=!!document.pointerLockElement);
document.addEventListener('mousemove',e=>{
  if(locked&&document.getElementById('hud').style.display!=='none'){
    mdx+=e.movementX||0; mdy+=e.movementY||0;
  }
});
document.addEventListener('keydown',e=>{
  if(e.code==='Escape'&&document.getElementById('hud').style.display!=='none'){
    document.exitPointerLock(); showMenu();
  }
});

// â”€â”€ PHYSICS + BUNNY HOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRAVITY=-22, SPEED=9, JUMP_VEL=11;
const BHOP_SPEED_BOOST=1.18; // speed multiplier on perfect bhop
const COYOTE_TIME=0.12;      // seconds after leaving edge you can still jump
const JUMP_BUFFER=0.12;      // seconds before landing jump is buffered

function resolveGround(pos,vel){
  let landed=false;
  const hp=PLATE_SIZE/2;
  if(pos.x>-hp&&pos.x<hp&&pos.z>-hp&&pos.z<hp&&pos.y<.01){pos.y=0;landed=true;}
  for(const p of platforms){
    const hw=p.w/2,hd=p.d/2,top=p.y+p.h/2;
    if(pos.x>p.x-hw&&pos.x<p.x+hw&&pos.z>p.z-hd&&pos.z<p.z+hd){
      if(pos.y>=top-.2&&pos.y<=top+.9&&vel.y<=0){pos.y=top;landed=true;}
    }
  }
  if(pos.y<-25){pos.set(0,3,0);vel.set(0,0,0);}
  return landed;
}

// â”€â”€ WEBSOCKET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ws=null,lobbyId='public',sendTimer=0,wsRetryCount=0;

function connectWS(lobby){
  lobbyId=lobby;
  showStatus('Connecting...');

  // Close existing connection cleanly
  if(ws){try{ws.onclose=null;ws.close();}catch(e){}}

  try{ ws=new WebSocket(WS_SERVER); }
  catch(e){ showStatus('Bad server URL'); return; }

  const timeout=setTimeout(()=>{
    if(ws.readyState!==WebSocket.OPEN){
      showStatus('Connection timed out, retrying...');
      ws.close();
    }
  },8000);

  ws.onopen=()=>{
    clearTimeout(timeout);
    wsRetryCount=0;
    ws.send(JSON.stringify({type:'join',lobby,name:player.name,color:player.color}));
    showStatus('Connected! âœ“');
  };

  ws.onmessage=(e)=>{
    let m;try{m=JSON.parse(e.data);}catch{return;}
    switch(m.type){
      case 'welcome':
        player.id=m.id;
        document.getElementById('lcode').textContent='Lobby: '+(lobby==='public'?'PUBLIC':lobby.toUpperCase());
        break;
      case 'state':
        Object.keys(remotes).forEach(id=>{if(!m.players[id])removeRemote(id);});
        Object.entries(m.players).forEach(([id,d])=>{if(id!==player.id)moveRemote(id,d);});
        document.getElementById('pcount').textContent='Players: '+Object.keys(m.players).length;
        break;
      case 'player_join':
        if(m.id!==player.id){spawnRemote(m.id,m);showStatus(m.name+' joined!');}
        break;
      case 'player_leave':
        removeRemote(m.id);showStatus((m.name||'Someone')+' left');
        break;
      case 'player_move':
        if(m.id!==player.id)moveRemote(m.id,m);
        document.getElementById('pcount').textContent='Players: '+(Object.keys(remotes).length+1);
        break;
    }
  };

  ws.onclose=(e)=>{
    clearTimeout(timeout);
    if(document.getElementById('hud').style.display==='none')return;
    wsRetryCount++;
    const delay=Math.min(1000*wsRetryCount,8000);
    showStatus('Reconnecting in '+(delay/1000).toFixed(0)+'s...');
    setTimeout(()=>{
      if(document.getElementById('hud').style.display!=='none')connectWS(lobbyId);
    },delay);
  };

  ws.onerror=(err)=>{
    // onerror always fires before onclose, let onclose handle retry
    showStatus('Connection error...');
  };
}

function sendMove(){
  if(!ws||ws.readyState!==WebSocket.OPEN)return;
  ws.send(JSON.stringify({
    type:'move',x:player.pos.x,y:player.pos.y,z:player.pos.z,
    yaw:player.yaw,name:player.name
  }));
}

// â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showMenu(){
  document.body.classList.remove('ingame');
  player.canMove=false;
  document.getElementById('menu').style.display='block';
  document.getElementById('hud').style.display='none';
}
function hideMenu(){
  document.body.classList.add('ingame');
  player.canMove=true;   // â† movement ENABLED only after joining
  document.getElementById('menu').style.display='none';
  document.getElementById('hud').style.display='block';
  const hint=document.getElementById('rmb-hint');
  hint.style.opacity='1';
  setTimeout(()=>hint.style.opacity='0',3000);
}
function showStatus(msg){
  const el=document.getElementById('status');
  el.textContent=msg;el.style.opacity='1';
  clearTimeout(el._t);el._t=setTimeout(()=>el.style.opacity='0',3500);
}

document.getElementById('joinPublicBtn').onclick=()=>{
  player.name=document.getElementById('nameInput').value.trim()||'Monkey';
  setName(localMonkey,player.name);hideMenu();connectWS('public');
};
document.getElementById('hostBtn').onclick=()=>{
  const pb=document.getElementById('privateBox');
  pb.style.display=pb.style.display==='none'?'block':'none';
  if(pb.style.display==='block'){
    const code=Math.random().toString(36).substring(2,8).toUpperCase();
    document.getElementById('codeInput').value=code;
    player.name=document.getElementById('nameInput').value.trim()||'Monkey';
    setName(localMonkey,player.name);hideMenu();connectWS(code.toLowerCase());
    showStatus('Code: '+code);
  }
};
document.getElementById('joinPrivBtn').onclick=()=>{
  const code=document.getElementById('codeInput').value.trim().toLowerCase();
  if(!code)return;
  player.name=document.getElementById('nameInput').value.trim()||'Monkey';
  setName(localMonkey,player.name);hideMenu();connectWS(code);
};

// â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clock=new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt=Math.min(clock.getDelta(),.05);

  const inGame=document.getElementById('hud').style.display!=='none';

  if(inGame){
    // â”€â”€ Mouse look â”€â”€
    if(mdx!==0||mdy!==0){
      player.yaw  -=mdx*.0022;
      player.pitch=Math.max(-.45,Math.min(.85,player.pitch-mdy*.0022));
      mdx=0;mdy=0;
    }

    if(player.canMove){
      // â”€â”€ Movement input â”€â”€
      const md=new THREE.Vector3();
      if(keys['KeyW']||keys['ArrowUp'])    md.z-=1;
      if(keys['KeyS']||keys['ArrowDown'])  md.z+=1;
      if(keys['KeyA']||keys['ArrowLeft'])  md.x-=1;
      if(keys['KeyD']||keys['ArrowRight']) md.x+=1;
      md.normalize();
      player.moving=md.lengthSq()>0;

      const fwd=new THREE.Vector3(-Math.sin(player.yaw),0,-Math.cos(player.yaw));
      const rgt=new THREE.Vector3(Math.cos(player.yaw),0,-Math.sin(player.yaw));
      const mv=fwd.multiplyScalar(-md.z).add(rgt.multiplyScalar(md.x));

      // â”€â”€ Bunny Hop â”€â”€
      // Track coyote time (allows jumping just after walking off edge)
      if(player.wasOnGround&&!player.onGround){
        player.coyoteTime=COYOTE_TIME;
      } else {
        player.coyoteTime=Math.max(0,player.coyoteTime-dt);
      }

      // Jump buffer (pressed just before landing still triggers jump)
      if(keys['Space']){
        player.jumpBufferTime=JUMP_BUFFER;
      } else {
        player.jumpBufferTime=Math.max(0,player.jumpBufferTime-dt);
      }

      const canJump=player.onGround||player.coyoteTime>0;
      const wantsJump=player.jumpBufferTime>0;

      if(canJump&&wantsJump){
        // Bunny hop: if you jump again quickly after landing, keep momentum + slight boost
        const horizSpeed=Math.sqrt(player.vel.x**2+player.vel.z**2);
        player.vel.y=JUMP_VEL;
        player.onGround=false;
        player.coyoteTime=0;
        player.jumpBufferTime=0;

        // Preserve and slightly boost horizontal speed for bhop feel
        if(horizSpeed>0.5){
          const boost=BHOP_SPEED_BOOST;
          player.vel.x*=boost; player.vel.z*=boost;
          // Cap max bhop speed
          const maxBhop=SPEED*2.5;
          const newSpd=Math.sqrt(player.vel.x**2+player.vel.z**2);
          if(newSpd>maxBhop){player.vel.x=player.vel.x/newSpd*maxBhop;player.vel.z=player.vel.z/newSpd*maxBhop;}
        }

        // Jump VFX
        spawnJumpRing(player.pos.x,player.pos.y,player.pos.z);
      }

      // Horizontal movement (only override if on ground or adding input)
      if(player.onGround){
        player.vel.x=mv.x*SPEED;
        player.vel.z=mv.z*SPEED;
      } else {
        // Air control (partial steering in air)
        player.vel.x+=mv.x*SPEED*dt*3.5;
        player.vel.z+=mv.z*SPEED*dt*3.5;
        // Air drag
        player.vel.x*=0.98; player.vel.z*=0.98;
      }

      // Gravity
      if(!player.onGround)player.vel.y+=GRAVITY*dt;

      // Integrate position
      player.pos.x+=player.vel.x*dt;
      player.pos.y+=player.vel.y*dt;
      player.pos.z+=player.vel.z*dt;

      // Bounds
      player.pos.x=Math.max(-60,Math.min(60,player.pos.x));
      player.pos.z=Math.max(-60,Math.min(60,player.pos.z));

      // Ground resolution
      player.wasOnGround=player.onGround;
      player.onGround=resolveGround(player.pos,player.vel);
      if(player.onGround&&player.vel.y<0){
        // Land puff VFX if falling fast enough
        if(player.vel.y<-4)spawnLandPuff(player.pos.x,player.pos.y,player.pos.z);
        player.vel.y=0;
      }
    }

    // â”€â”€ Update monkey visuals â”€â”€
    localMonkey.position.set(player.pos.x,player.pos.y,player.pos.z);
    localMonkey.rotation.y=player.yaw+Math.PI;
    animateMonkey(localMonkey,player.moving,!player.onGround,dt);

    // â”€â”€ Third-person camera â”€â”€
    const cx=player.pos.x+Math.sin(player.yaw)*CAM_DIST;
    const cz=player.pos.z+Math.cos(player.yaw)*CAM_DIST;
    const cy=player.pos.y+CAM_HEIGHT+player.pitch*2;
    camera.position.set(cx,cy,cz);
    camera.lookAt(player.pos.x,player.pos.y+1.55,player.pos.z);

    // â”€â”€ VFX â”€â”€
    updateVFX(dt);

    // â”€â”€ Animate remote monkeys â”€â”€
    Object.values(remotes).forEach(r=>animateMonkey(r.monkey,r.moving,r.inAir,dt));

    // â”€â”€ Network send â”€â”€
    sendTimer+=dt;
    if(sendTimer>.05){sendMove();sendTimer=0;}
  }

  renderer.render(scene,camera);
}

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

animate();
</script>
</body>
</html>
